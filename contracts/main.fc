;; op - 1 - create campaign
;; op - 2 - deposit in campaign ;; todo - remove make the create campaign and deposit same
;; op - 3 - create affiliate
;; op - 4 - withdraw amount from campaign and tranfer to affiliate

#include "imports/stdlib.fc";

const const::min_tons_for_storage = 10000000; ;; 0.01 TON

(slice, int, slice, cell, cell, cell) load_data() inline {
    slice ds =  get_data().begin_parse();
    ;; int affiliate_clicks = ds~load_uint(32); ;; later implement it support web2 db vs web3 does match again become problem
    slice admin_address = ds~load_msg_addr();
    int budget = ds~load_uint(32);
    slice campaign_wallet_address = ds~load_msg_addr();
    cell category = ds~load_ref();
    cell company_name = ds~load_ref();
    cell original_url = ds~load_ref();
    
    return (admin_address, budget, campaign_wallet_address, category, company_name, original_url);
}

() save_data(slice admin_address, int budget, slice campaign_wallet_address, cell category, cell company_name, cell original_url) impure inline {
    set_data(
            begin_cell()
            .store_slice(admin_address)
            .store_uint(budget, 32)
            .store_slice(campaign_wallet_address)
            .store_ref(category)
            .store_ref(company_name)
            .store_ref(original_url)
            .end_cell()
        );
}

() recv_internal(int msg_value, cell in_msg, slice in_msg_body) impure {
    slice cs = in_msg.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);

     var (admin_address, budget, campaign_wallet_address, category, company_name, original_url) = load_data();
    
    if(op == 1){
        ;; todo check whether amount is deposting or not when passing value in wrapper typescript
        save_data(admin_address, budget, campaign_wallet_address, category, company_name, original_url);
        return ();
    }

    if(op == 2){
        ;;todo - check this is suitable for support feature
        return ();
    }
    
    if(op == 3){
        throw_unless(103, equal_slice_bits(sender_address, admin_address));
        int withdraw_amount = in_msg_body~load_coins();
        slice affiliate_address = in_msg_body~load_msg_addr();
        var [balance, _] = get_balance(); ;;smart contract balanace
        throw_unless(104, balance >= withdraw_amount);

        int return_value = min(withdraw_amount, balance - const::min_tons_for_storage);

        int msg_mode = 1; ;; 0 (Ordinary message) + 1 (Pay transfer fees separately from the message value)
    
        var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(affiliate_address) ;; destination address ;; might be affiliate address
            .store_coins(return_value)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);
        
        send_raw_message(msg.end_cell(), msg_mode);
        
        return ();
    }

    if( op == 4){
        return ();
    }

    throw(777);
}

(int) balance() method_id {
    var [balance, _] = get_balance();
    return balance;
}